import java.nio.file.Paths
import org.apache.tools.ant.taskdefs.condition.Os

CargoKitPlugin.file = buildscript.sourceFile

apply plugin: CargoKitPlugin

// Helper function to detect target device architecture from Flutter
def detectTargetDeviceArchitecture(project) {
    try {
        // Check if Flutter is targeting a specific device
        // This is set when flutter run -d <device_id> is used
        def targetDeviceId = System.getenv("FLUTTER_TARGET_DEVICE_ID")

        // Also check for emulator flag
        def isEmulator = System.getenv("FLUTTER_EMULATOR") == "true"

        // Check project properties set by Flutter
        if (project.hasProperty('target-platform')) {
            // Flutter explicitly specified the platform
            return project.property('target-platform')
        }

        // If no specific device targeted, check what Flutter run is actually using
        // Flutter sets the ANDROID_EMULATOR environment variable when targeting emulator
        if (System.getenv("ANDROID_EMULATOR") != null || isEmulator) {
            // Building for emulator - use x64
            return 'android-x64'
        }

        // Try to detect based on ADB if we have a specific device ID
        def adbPath = project.android.sdkDirectory.path + "/platform-tools/adb"

        if (targetDeviceId != null) {
            // Get architecture of specific device
            def archOutput = new ByteArrayOutputStream()
            project.exec {
                commandLine adbPath, '-s', targetDeviceId, 'shell', 'getprop', 'ro.product.cpu.abi'
                standardOutput = archOutput
            }

            def abi = archOutput.toString().trim()

            // Map Android ABI to Flutter platform name
            switch(abi) {
                case 'arm64-v8a':
                    return 'android-arm64'
                case 'armeabi-v7a':
                    return 'android-arm'
                case 'x86_64':
                    return 'android-x64'
            }
        }

        // Last resort: try to detect any connected physical device
        // But only if we're sure we're not targeting an emulator
        if (!isEmulator) {
            def devicesOutput = new ByteArrayOutputStream()
            project.exec {
                commandLine adbPath, 'devices'
                standardOutput = devicesOutput
            }

            // Find physical devices (exclude emulators)
            def devices = devicesOutput.toString().readLines()
                .findAll { it.contains('\tdevice') && !it.contains('emulator-') }
                .collect { it.split('\t')[0] }

            if (devices.size() == 1) {
                // Only one physical device connected, probably targeting it
                def archOutput = new ByteArrayOutputStream()
                project.exec {
                    commandLine adbPath, '-s', devices[0], 'shell', 'getprop', 'ro.product.cpu.abi'
                    standardOutput = archOutput
                }

                def abi = archOutput.toString().trim()

                switch(abi) {
                    case 'arm64-v8a':
                        return 'android-arm64'
                    case 'armeabi-v7a':
                        return 'android-arm'
                    case 'x86_64':
                        return 'android-x64'
                }
            }
        }

        return null
    } catch (Exception e) {
        // ADB not available or detection failed
        return null
    }
}

class CargoKitExtension {
    String manifestDir; // Relative path to folder containing Cargo.toml
    String libname; // Library name within Cargo.toml. Must be a cdylib
}

abstract class CargoKitBuildTask extends DefaultTask {

    @Input
    String buildMode

    @Input
    String buildDir

    @Input
    String outputDir

    @Input
    String ndkVersion

    @Input
    String sdkDirectory

    @Input
    int compileSdkVersion;

    @Input
    int minSdkVersion;

    @Input
    String pluginFile

    @Input
    List<String> targetPlatforms

    @TaskAction
    def build() {
        if (project.cargokit.manifestDir == null) {
            throw new GradleException("Property 'manifestDir' must be set on cargokit extension");
        }

        if (project.cargokit.libname == null) {
            throw new GradleException("Property 'libname' must be set on cargokit extension");
        }

        def executableName = Os.isFamily(Os.FAMILY_WINDOWS) ? "run_build_tool.cmd" : "run_build_tool.sh"
        def path = Paths.get(new File(pluginFile).parent, "..", executableName);

        def manifestDir = Paths.get(project.buildscript.sourceFile.parent, project.cargokit.manifestDir)

        def rootProjectDir = project.rootProject.projectDir

        if (!Os.isFamily(Os.FAMILY_WINDOWS)) {
            project.exec {
                commandLine 'chmod', '+x', path
            }
        }

        project.exec {
            executable path
            args "build-gradle"
            environment "CARGOKIT_ROOT_PROJECT_DIR", rootProjectDir
            environment "CARGOKIT_TOOL_TEMP_DIR", "${buildDir}/build_tool"
            environment "CARGOKIT_MANIFEST_DIR", manifestDir
            environment "CARGOKIT_CONFIGURATION", buildMode
            environment "CARGOKIT_TARGET_TEMP_DIR", buildDir
            environment "CARGOKIT_OUTPUT_DIR", outputDir
            environment "CARGOKIT_NDK_VERSION", ndkVersion
            environment "CARGOKIT_SDK_DIR", sdkDirectory
            environment "CARGOKIT_COMPILE_SDK_VERSION", compileSdkVersion
            environment "CARGOKIT_MIN_SDK_VERSION", minSdkVersion
            environment "CARGOKIT_TARGET_PLATFORMS", targetPlatforms.join(",")
            environment "CARGOKIT_JAVA_HOME", System.properties['java.home']
        }
    }
}

class CargoKitPlugin implements Plugin<Project> {

    static String file;

    private Plugin findFlutterPlugin(Project rootProject) {
        _findFlutterPlugin(rootProject.childProjects)
    }

   private Plugin _findFlutterPlugin(Map projects) {
        for (project in projects) {
            for (plugin in project.value.getPlugins()) {
                if (plugin.class.name == "com.flutter.gradle.FlutterPlugin") {
                    return plugin;
                }
            }
            def plugin = _findFlutterPlugin(project.value.childProjects);
            if (plugin != null) {
                return plugin;
            }
        }
        return null;
    }

    @Override
    void apply(Project project) {
        def plugin = findFlutterPlugin(project.rootProject);

        project.extensions.create("cargokit", CargoKitExtension)

        if (plugin == null) {
            print("Flutter plugin not found, CargoKit plugin will not be applied.")
            return;
        }

        def cargoBuildDir = "${project.buildDir}/build"

        // Determine if the project is an application or library
        def isApplication = plugin.project.plugins.hasPlugin('com.android.application')
        def variants = isApplication ? plugin.project.android.applicationVariants : plugin.project.android.libraryVariants

        variants.all { variant ->

            final buildType = variant.buildType.name

            def cargoOutputDir = "${project.buildDir}/jniLibs/${buildType}";
            def jniLibs = project.android.sourceSets.maybeCreate(buildType).jniLibs;
            jniLibs.srcDir(new File(cargoOutputDir))

            def platforms = com.flutter.gradle.FlutterPluginUtils.getTargetPlatforms(project).collect()

            // Smart architecture detection for development builds
            if (buildType == "debug") {
                // Check if Flutter is in single-device mode
                // When running with a specific device, Flutter should only pass one platform
                def originalPlatformCount = platforms.size()

                // For debug builds, Flutter might add extra platforms for compatibility
                // We want to detect the actual target device
                def targetPlatform = null

                // Check various properties that Flutter might set
                if (project.hasProperty('target-platform')) {
                    targetPlatform = project.property('target-platform')
                } else if (project.hasProperty('flutter.target-platform')) {
                    targetPlatform = project.property('flutter.target-platform')
                }

                // If we have a specific target, use only that
                if (targetPlatform != null) {
                    println("CargoKit: Debug build for specific platform: ${targetPlatform}")
                    platforms = [targetPlatform]
                } else {
                    // Try to intelligently detect based on what we know
                    // Check if this is likely an emulator build
                    def hasX64 = platforms.contains('android-x64')
                    def hasArm64 = platforms.contains('android-arm64')

                    // If we have both x64 and arm64, this is likely Flutter adding both for compatibility
                    // Try to detect which one is actually being used
                    if (hasX64 && hasArm64 && originalPlatformCount > 1) {
                        // Try our detection function
                        def detectedArch = detectTargetDeviceArchitecture(project)
                        if (detectedArch != null) {
                            println("CargoKit: Detected actual target: ${detectedArch}")
                            platforms = [detectedArch]
                        } else {
                            // Can't detect, keep both but log
                            println("CargoKit: Debug build with multiple platforms (${platforms}), couldn't detect specific target")
                        }
                    } else if (originalPlatformCount == 1) {
                        // Single platform already, use it
                        println("CargoKit: Debug build for single platform: ${platforms[0]}")
                    }
                }
            }
            // For release builds, use all platforms as determined by Flutter

            // The task name depends on plugin properties, which are not available
            // at this point
            project.getGradle().afterProject {
                def taskName = "cargokitCargoBuild${project.cargokit.libname.capitalize()}${buildType.capitalize()}";

                if (project.tasks.findByName(taskName)) {
                    return
                }

                if (plugin.project.android.ndkVersion == null) {
                    throw new GradleException("Please set 'android.ndkVersion' in 'app/build.gradle'.")
                }

                def task = project.tasks.create(taskName, CargoKitBuildTask.class) {
                    buildMode = variant.buildType.name
                    buildDir = cargoBuildDir
                    outputDir = cargoOutputDir
                    ndkVersion = plugin.project.android.ndkVersion
                    sdkDirectory = plugin.project.android.sdkDirectory
                    minSdkVersion = plugin.project.android.defaultConfig.minSdkVersion.apiLevel as int
                    compileSdkVersion = plugin.project.android.compileSdkVersion.substring(8) as int
                    targetPlatforms = platforms
                    pluginFile = CargoKitPlugin.file
                }
                def onTask = { newTask ->
                    if (newTask.name == "merge${buildType.capitalize()}NativeLibs") {
                        newTask.dependsOn task
                        // Fix gradle 7.4.2 not picking up JNI library changes
                        newTask.outputs.upToDateWhen { false }
                    }
                }
                project.tasks.each onTask
                project.tasks.whenTaskAdded onTask
            }
        }
    }
}
